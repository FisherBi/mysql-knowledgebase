
5.3.6  覆盖索引
如果一个索引包含所有需要查询的字段的值，我们就称之为覆盖索引。
覆盖索引的好处：
索引条目远小于数据行大小，如果只需读取索引，极大减少数据访问量。对缓存的负载非常重要，这种情况响应时间大部分花在数据拷贝上。对于I/O密集型的应用也有帮助，索引比数据更小，容易放进内存。

不是所有索引都可以成为覆盖索引，覆盖索引必须存储索引列的值，哈希，空间，全文索引都不行，Mysql只能使用B-Tree索引做覆盖索引。

索引无法覆盖该查询，原因有两个：
1. 没有任何索引能够覆盖这个查询。因为查询从表中选择了所有列，而没有任何索引覆盖所有列。
2.Mysql不能在索引中执行Like操作。可以最左前缀匹配，如果通配符开头则不行。
5.3.7 使用索引扫描来做排序
MySQL有两种方式生成有序结果：1.通过排序操作。2.按索引顺序扫描。如果EXPLAIN出来的type列的值是“index”,则说明使用索引扫描来做排序。
只有当索引的列顺序和ORDER BY子句顺序完全一致，并且所有列的排序方向都一样，才能使用索引来排序。
如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能用索引做排序。
需要满足索引最左前缀要求，否则不行。有一种情况可行，前导列为常量。
5.3.8 压缩（前缀压缩）索引



压缩索引使用更少的空间，代价是操作更慢。无法使用二分查找，只能从头开始扫描。

5.3.9 冗余和重复索引

5.4.1 支持多种过虑条件
1. 将sex,country作为索引前缀。



5.4.2 避免多个范围条件


5.4.3 优化排序






5.5 维护索引和表
5.5.1 找到并修复损坏的表
遇到错误，尝试运行CHECK TABLE来检查是否发生表损坏。
可以使用REPAIR TABLE来修复损坏
InnoDB引擎损坏一定发生了严重错误，一般是硬件问题导致。
5.5.2 更新索引统计信息

5.5.3 减少索引和数据碎片


可以通过OPTIMIZE TABLE或者导入导出来重新整理数据。